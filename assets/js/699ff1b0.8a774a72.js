"use strict";(self.webpackChunklbt_docs=self.webpackChunklbt_docs||[]).push([[924],{27286:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"FrontEndDev/Interviews/ManualCode","title":"Manual Code","description":"","source":"@site/docs/FrontEndDev/Interviews/ManualCode.md","sourceDirName":"FrontEndDev/Interviews","slug":"/FrontEndDev/Interviews/ManualCode","permalink":"/docs/FrontEndDev/Interviews/ManualCode","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Manual Code","tag":["frontend"]},"sidebar":"tutorialSidebar","previous":{"title":"InterviewQuestions2","permalink":"/docs/FrontEndDev/Interviews/InterviewQuestions2"},"next":{"title":"Notes Of CSS","permalink":"/docs/FrontEndDev/Interviews/NotesOfCSS"}}');var o=t(74848),a=t(28453);const s={sidebar_position:4,title:"Manual Code",tag:["frontend"]},i="\u624b\u5199\u4ee3\u7801",l={},c=[];function u(n){const e={code:"code",h1:"h1",header:"header",pre:"pre",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"\u624b\u5199\u4ee3\u7801",children:"\u624b\u5199\u4ee3\u7801"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"export function flattenArray(arr: any[]): any[] {\n    return arr.reduce((acc, val) => {\n        if (Array.isArray(val)) acc = acc.concat(flattenArray(val));\n        else acc.push(val);\n        return acc;\n    }, []);\n\n}\n/**\n * \u83b7\u53d6\u6241\u5e73\u6570\u7ec4\n * @param arr \u3000\u9700\u8981\u62cd\u5e73\u7684\u6570\u7ec4\n * @param level \u3000\u83b7\u53d6\u7684\u5c42\u7ea7\n * @returns \n */\nexport function flattenArray2(arr: any[], level: number): any[] {\n    // const result: any[] = [];\n    let count = 0;\n    function getVal(a: any[]) {\n        const res: any[] = [];\n\n        for (const item of a) {\n            if (Array.isArray(item) && level >= count++) {\n                res.push(...getVal(item));\n            } else {\n                res.push(item);\n            }\n        }\n        return res;\n    }\n\n    return getVal(arr);\n\n    // return result;\n}\n\nexport function getType(value: any) {\n    return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n}\n\n\n/**\n * new \u64cd\u4f5c\u7b26\u5b9e\u73b0\n */\nexport function New<T>(constructor: Function, ...args: any[]): T {\n    //\u521b\u5efa\u65b0\u5bf9\u8c61\uff0c\u7ee7\u627fconstructor\u7684\u539f\u578b\n    const obj = Object.create(constructor.prototype);\n    //\u6267\u884c\u6784\u9020\u51fd\u6570\uff0c\u7ed1\u5b9athis\n    constructor.apply(obj, args);\n\n    return obj;\n}\n\n\nexport function visiteNode(node: Node) {\n    // console.dir(node);\n    if (node instanceof Text) {\n        const t = node.textContent?.trim();\n        if (t) {\n            console.info('\u6587\u672c\u8282\u70b9---', t);\n\n        }\n    }\n\n    if (node instanceof HTMLElement) {\n        console.info('\u6807\u7b7e\u8282\u70b9---', node.tagName.toLowerCase());\n    }\n}\n/**\n * \u6df1\u5ea6\u4f18\u5148\u904d\u5386\n * @param root \u6839\u8282\u70b9\n * @returns \n */\nexport function deepthFistTravse(root: Node) {\n    if (!root) return false;\n\n    visiteNode(root)\n\n    const childNodes = root.childNodes;\n    childNodes.forEach((node) => {\n        deepthFistTravse(node);\n    })\n\n}\n/**\n * \u5e7f\u5ea6\u4f18\u5316\u904d\u5386\n * @param root \u6839\u8282\u70b9\n * @returns \n */\nexport function breadthFistTravse(root: Node) {\n    if (!root) return false;\n\n    const queue: Node[] = [root];\n\n    while (queue.length) {\n        const node = queue.shift();\n\n        if (!node) continue;\n        visiteNode(node);\n\n\n        if (node) {\n            for (let i = 0; i < node.childNodes.length; i++) {\n                queue.push(node.childNodes[i]);\n            }\n        }\n    }\n}\n\n\nexport class LazyMan {\n\n    private name: string;\n\n    private task: Function[] = []\n    constructor(name: string) {\n        this.name = name;\n        setTimeout(() => {\n            this.next();\n        }, 100);\n    }\n\n    private next() {\n        const task = this.task.shift();\n        task && task();\n    }\n\n    eat(food: string) {\n        const eatTask = () => {\n            console.log(`${this.name} is eating ${food}`);\n            this.next();\n        };\n\n        this.task.push(eatTask);\n        return this;\n    }\n\n\n    sleep(time: number) {\n        const sleepTask = () => {\n            console.log(`${this.name} is sleeping.`);\n            setTimeout(() => {\n                console.log(`${this.name} is wake up`);\n                this.next();\n            }, time * 1000);\n        };\n        this.task.push(sleepTask);\n\n        return this;\n    }\n}\n\n\nexport function curry(fn: Function) {\n\n    let _args: any[] = [];\n\n    const fnParamsLen = fn.length;\n\n    const calc = function (this: any, ...args: any[]) {\n        _args = [..._args, ...args];\n        if (_args.length >= fnParamsLen) {\n            return fn.apply(this, _args.slice(0, fnParamsLen));\n        } else {\n            return calc;\n        }\n    }\n\n\n    return calc;\n}\n\nexport function myInstanceof(instance: any, origin: any): boolean {\n\n    if (instance == null) return false;\n    const type = typeof instance;\n    if (type !== 'object' && type !== 'function') {\n        return false;\n    }\n    let tmpInst = Object.getPrototypeOf(instance);\n    while (tmpInst) {\n        if (tmpInst === origin.prototype) {\n            return true;\n        }\n        tmpInst = Object.getPrototypeOf(tmpInst);\n    }\n\n    return false;\n}\n\n// @ts-ignore\nFunction.prototype.myBind = function (ctx: any, ...newArgs: any[]) {\n\n    const self = this;\n\n    return function (...args: any[]) {\n        return self.apply(ctx, newArgs.concat(args));\n    }\n\n}\n\n// @ts-ignore\nFunction.prototype.myCall = function (ctx: any, ...args: any[]) {\n    if (ctx === null || ctx === undefined) {\n        ctx = globalThis\n    }\n\n    if (typeof ctx !== 'object') {\n        ctx = new Object(ctx);\n    }\n\n    const fnKey = Symbol('fn');\n\n    ctx[fnKey] = this;\n    const result = ctx[fnKey](...args);\n    delete ctx[fnKey];\n\n    return result;\n\n}\n\n\nexport class EventBus {\n\n    private events: { [key: string]: { fn: Function, isOnce: boolean }[] } = {};\n\n    on(type: string, fn: Function, isOnce: boolean) {\n        this.events[type] = this.events[type] || [];\n        this.events[type].push({\n            fn,\n            isOnce\n        });\n    }\n\n    once(type: string, fn: Function) {\n        this.on(type, fn, true);\n    }\n\n    off(type: string, fn?: Function) {\n        if (!this.events[type]) return;\n        if (!fn) {\n            this.events[type] = [];\n        } else {\n            const index = this.events[type].findIndex(item => item.fn === fn);\n            index !== -1 && this.events[type].splice(index, 1);\n        }\n    }\n\n    emit(type: string, ...args: any[]) {\n        if (!this.events[type]) return;\n\n        this.events[type] = this.events[type].filter(item => {\n            item.fn(...args);\n            return !item.isOnce;\n        });\n    }\n}\n\n\nexport class LRUCache {\n    private len: number;\n\n    private data: Map<any, any> = new Map();\n\n    constructor(len: number) {\n        this.len = len;\n    }\n\n\n    set(key: any, value: any) {\n\n        if (this.data.has(key)) {\n            this.data.delete(key);\n            this.data.set(key, value);\n        } else {\n            this.data.set(key, value);\n        }\n\n        if (this.data.size > this.len) {\n            this.data.delete(this.data.keys().next().value);\n        }\n\n    }\n\n    get(key: any) {\n        if (this.data.has(key)) {\n            const value = this.data.get(key);\n\n            this.data.delete(key);\n            this.set(key, value);\n            return value;\n        } else {\n            return null;\n        }\n    }\n}\n\ninterface IDoubleNode {\n    val: any;\n    key: any;\n    next?: IDoubleNode | null;\n    prev?: IDoubleNode | null;\n}\n\nexport class LRUCache2 {\n    private capacity: number;\n    private dataLen: number = 0;\n    private data: { [key: string]: IDoubleNode } = {};\n    private head: IDoubleNode | null = null;\n    private tail: IDoubleNode | null = null;\n\n    constructor(capacity: number) {\n        if (capacity < 1) throw new Error('capacity must be greater than zero');\n\n        this.capacity = capacity;\n    }\n\n\n    moveToTail(curNode: IDoubleNode) {\n        if (curNode === this.tail) return;\n\n        const prev = curNode.prev;\n        const next = curNode.next;\n        if (prev) {\n            if (next) {\n                prev.next = next;\n\n            } else {\n                delete prev.next;\n            }\n        }\n\n        if (next) {\n\n            if (prev) {\n                next.prev = prev;\n\n            } else {\n                delete next.prev;\n            }\n\n            if (this.head === curNode) {\n                this.head = next;\n            }\n        }\n\n        delete curNode.next;\n        delete curNode.prev;\n\n        if (this.tail) {\n            this.tail.next = curNode;\n            curNode.prev = this.tail;\n        }\n\n        this.tail = curNode;\n    }\n\n    tryClean() {\n        while (this.dataLen > this.capacity) {\n\n            if (!this.head) {\n                throw new Error('head is null');\n            }\n            const nextNode = this.head.next;\n            const delKey = this.head.key;\n\n            if (!nextNode) {\n                throw new Error('next node is null');\n            }\n\n\n            delete nextNode.prev;\n            delete this.head.next;\n\n            this.head = nextNode;\n\n\n            delete this.data[delKey];\n            this.dataLen--;\n        }\n    }\n\n    set(key: any, value: any) {\n\n        const curNode = this.data[key];\n\n        if (!curNode) {\n            const newNode = { key, val: value };\n\n            this.moveToTail(newNode);\n            this.data[key] = newNode;\n            this.dataLen++;\n\n            if (this.dataLen === 1) {\n                this.head = newNode;\n            }\n\n\n        } else {\n            curNode.val = value;\n            this.moveToTail(curNode);\n        }\n\n        this.tryClean();\n\n    }\n\n\n    get(key: any): any {\n        const curNode = this.data[key];\n        if (!curNode) return null;\n\n        if (curNode !== this.tail) {\n            this.moveToTail(curNode);\n        }\n\n        return curNode.val;\n    }\n}\n\n\nexport function deepClone(obj: any, wmap: WeakMap<any, any> = new WeakMap()) {\n    let result: any = {};\n    if (obj === null) return obj;\n\n    if (typeof obj !== 'object') return obj;\n\n    if (wmap.has(obj)) return wmap.get(obj);\n    wmap.set(obj, result);\n\n    if (obj instanceof Map) {\n        result = new Map();\n        for (let [key, value] of obj) {\n            result.set(deepClone(key, wmap), deepClone(value, wmap));\n        }\n        return result;\n\n    }\n\n    if (obj instanceof Set) {\n        result = new Set();\n        for (let value of obj) {\n            result.add(deepClone(value, wmap));\n        }\n        return result;\n\n    }\n\n    if (Array.isArray(obj)) {\n        result = [];\n        for (let i = 0; i < obj.length; i++) {\n            result[i] = deepClone(obj[i], wmap);\n        }\n        return result;\n    }\n\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n\n            result[key] = deepClone(obj[key], wmap);\n        }\n    }\n\n    return result;\n}\n\n\ninterface ITreeNode {\n    id: number;\n    name: string;\n    children?: ITreeNode[];\n}\nexport function covertArrToTree(arr: any[]) {\n    const treeIdMap: Map<number, ITreeNode> = new Map();\n    let rootNode: ITreeNode | null = null;\n    arr.forEach((item) => {\n        const node: ITreeNode = {\n            id: item.id,\n            name: item.name,\n        };\n\n        const parent = treeIdMap.get(item.parentId);\n\n        if (parent) {\n            parent.children = parent.children || [];\n            parent.children.push(node);\n        }\n\n        if (item.parentId === 0) {\n            rootNode = node;\n        }\n\n        treeIdMap.set(item.id, node);\n\n\n    });\n\n\n    return rootNode;\n}\n\n\n\nexport function covertTreeToArr(obj: any) {\n    const pidMap: Map<number, any> = new Map();\n\n    const result: any[] = [];\n    const queue: any[] = [obj];\n\n    while (queue.length) {\n        const node = queue.shift();\n\n        const item = {\n            id: node.id,\n            name: node.name,\n            parentId: pidMap.get(node.id) || 0,\n        };\n\n        result.push(item);\n\n        if (node.children) {\n            for (let child of node.children) {\n                queue.push(child);\n                pidMap.set(child.id, node.id);\n            }\n\n        }\n\n    }\n\n    return result;\n}\n\n\n\n"})})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>i});var r=t(96540);const o={},a=r.createContext(o);function s(n){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);